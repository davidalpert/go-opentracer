// +build ignore

// This program generates version.go. It can be invoked by running invoking go:generate
package main

import (
	_ "embed"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"text/template"
	"time"
)

//go:embed VERSION
var versionStem string

func main() {
	if len(os.Args) < 2 {
		fmt.Printf("usage: go run version_gen.go <appName>")
		os.Exit(1)
	}

	gitBranch, err := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD").Output()
	//fmt.Printf("branch: >%s< (err: %#v)\n", string(gitBranch), err)
	if err != nil {
		panic(err)
	}

	gitSHA, err := exec.Command("git", "rev-parse", "--short", "HEAD").Output()
	//fmt.Printf("sha: >%s< (err: %#v)\n", string(gitSHA), err)
	if err != nil {
		panic(err)
	}

	var hasStaged bool
	if _, err := exec.Command("git", "diff-index", "--quiet", "--cached", "HEAD", "--").Output(); err != nil {
		hasStaged = true
	}

	var hasModified bool
	if _, err := exec.Command("git", "diff-files", "--quiet").Output(); err != nil {
		hasModified = true
	}

	var hasUntracked bool
	if _, err := exec.Command("git", "ls-files", "--exclude-standard", "--others").Output(); err != nil {
		hasUntracked = true
	}

	var isDirty = hasStaged || hasModified || hasUntracked

	_, err = exec.Command("mkdir", "-p", "./internal/version").Output()
	if err != nil {
		panic(err)
	}

	fmt.Printf("generating/updating: ./internal/version/detail.go\n")
	f, err := os.Create("internal/version/detail.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	packageTemplate.Execute(f, struct {
		AppName      string
		Version      string
		Branch       string
		SHA          string
		HasStaged    bool
		HasModified  bool
		HasUntracked bool
		IsDirty      bool
		Timestamp    time.Time
	}{
		AppName:      os.Args[1],
		Version:      strings.Trim(versionStem, "\r\n"),
		Branch:       strings.Trim(string(gitBranch), "\r\n"),
		SHA:          strings.Trim(string(gitSHA), "\r\n"),
		HasStaged:    hasStaged,
		HasModified:  hasModified,
		HasUntracked: hasUntracked,
		IsDirty:      isDirty,
		Timestamp:    time.Now(),
	})
}

var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at {{ .Timestamp }}
package version

import (
	"fmt"
	"os/user"
	"runtime"
	"sort"
	"strings"
)

// SummaryStruct provides an easy way to grab all the govvv version details together
type SummaryStruct struct {
	AppName              string `+"`json:\"app_name\"`"+`
	BuildDate            string `+"`json:\"build_date\"`"+`
	GitBranch            string `+"`json:\"branch\"`"+`
	GitCommit            string `+"`json:\"commit\"`"+`
	GitDirty             bool `+"`json:\"dirty\"`"+`
	GitDirtyHasModified  bool `+"`json:\"dirty_modified\"`"+`
	GitDirtyHasStaged    bool `+"`json:\"dirty_staged\"`"+`
	GitDirtyHasUntracked bool `+"`json:\"dirty_untracked\"`"+`
	GitWorkingState      string `+"`json:\"working_state\"`"+`
	GitSummary           string `+"`json:\"summary\"`"+`
	UserAgentString      string `+"`json:\"user_agent\"`"+`
	Version              string `+"`json:\"version\"`"+`
}

// NewVersionSummary builds a new version SummaryStruct
func NewVersionSummary() SummaryStruct {
	s := SummaryStruct{
		AppName:              "{{ .AppName }}",
		BuildDate:            "{{ .Timestamp }}",
		GitBranch:            "{{ .Branch }}",
		GitCommit:            "{{ .SHA }}",
		GitDirty:             {{ .IsDirty }},
		GitDirtyHasModified:  {{ .HasModified }},
		GitDirtyHasStaged:    {{ .HasStaged }},
		GitDirtyHasUntracked: {{ .HasUntracked }},
		GitSummary:           "{{ .Timestamp }}",
		GitWorkingState:      "",
		Version:              "{{ .Version }}",
	}
	s.UserAgentString = s.ToUserAgentString()
	if s.GitDirty {
		s.GitWorkingState = "dirty"
	}
	return s
}

// Summary provides an easy global way to
var Summary = NewVersionSummary()

func (s SummaryStruct) String() string {
	vs := fmt.Sprintf("%s %s-%s", s.AppName, s.Version, s.GitCommit)
    if strings.EqualFold(s.GitBranch, "main") {
		return vs
	}

	return fmt.Sprintf("%s [%s]", vs, s.GitBranch)
}

// ToUserAgentString formats a SummaryStruct as a User-Agent string
func (s SummaryStruct) ToUserAgentString() string {
	productName := s.AppName
	productVersion := s.Version

	productDetails := map[string]string{
		"sha": s.GitCommit,
	}

	if s.GitBranch != "main" {
		productDetails["branch"] = s.GitBranch
	}

	if s.GitDirty {
		productDetails["dirty"] = "true"
	}

	user, err := user.Current()
	if err == nil {
		username := user.Username
		if username == "" {
			username = "unknown"
		}

		productDetails["user"] = username
	}

	detailParts := []string{}
	for k, v := range productDetails {
		detailParts = append(detailParts, fmt.Sprintf("%s: %s", k, v))
	}
	sort.Slice(detailParts, func(i, j int) bool {
		return detailParts[i] < detailParts[j]
	})
	productDetail := strings.Join(detailParts, ", ")

	return fmt.Sprintf("%s/%s (%s) %s (%s)", productName, productVersion, productDetail, runtime.GOOS, runtime.GOARCH)
}
`))