package version

import (
	_ "embed"
	"fmt"
	"os/user"
	"runtime"
	"runtime/debug"
	"sort"
	"strings"
	"time"
)

// Detail provides an easy global way to
var Detail = newVersionDetail()

// embedding the app name means we do not have to hard-code it in this version file

//go:embed _APPNAME.txt
var AppName string

// note: these props are not yet available in golang's runtime debug info ---------------------
//       (for now provide them by embedding files generated by the build)

//go:embed _APPVERSION.txt
var AppVersion string // a.k.a. git tag

//go:embed _GITBRANCH.txt
var GitBranch string

// --------------------------------------------------------------------------------------------

type debugBuildInfo struct {
	GOARCH       string // the architecture target
	GOOS         string // the operating system target
	vcs          string // the version control system for the source tree where the build ran
	vcs_revision string // the revision identifier for the current commit or checkout
	vcs_time     string // the modification time associated with vcs.revision, in RFC3339 format
	vcs_modified string // true or false indicating whether the source tree had local modifications
}

func readDebugBuildInfo() debugBuildInfo {
	info := debugBuildInfo{
		GOARCH:       "unkown",
		GOOS:         "unknown",
		vcs:          "unknown",
		vcs_revision: "unknown",
		vcs_time:     "unknown",
		vcs_modified: "unknown",
	}

	if readInfo, ok := debug.ReadBuildInfo(); ok {
		//fmt.Printf("BUILDINFO: %#v\n", readInfo)
		for _, setting := range readInfo.Settings {
			switch setting.Key {
			case "GOARCH":
				info.GOARCH = setting.Value
			case "GOOS":
				info.GOOS = setting.Value
			case "vcs":
				info.vcs = setting.Value
			case "vcs.revision":
				info.vcs_revision = setting.Value
			case "vcs.time":
				info.vcs_time = setting.Value
			case "vcs.modified":
				info.vcs_modified = setting.Value
			}
		}
	}

	return info
}

// newVersionDetail builds a new version DetailStruct
func newVersionDetail() DetailStruct {
	info := readDebugBuildInfo()
	s := DetailStruct{
		AppName:     strings.TrimSpace(AppName),
		BuildDate:   time.Now().String(),
		CoreVersion: strings.TrimSpace(AppVersion),
		GitBranch:   strings.TrimSpace(GitBranch),
		GitCommit:   info.vcs_revision,
		GitDirty:    info.vcs_modified != "false",
	}
	s.Version = generateSemanticVersion(s.CoreVersion, s.GitBranch, s.GitCommit, s.GitDirty)
	s.UserAgentString = s.ToUserAgentString()
	return s
}

// DetailStruct provides an easy way to grab all the govvv version details together
type DetailStruct struct {
	AppName         string `json:"app_name"`
	BuildDate       string `json:"build_date"`
	CoreVersion     string `json:"core_version"`
	GitBranch       string `json:"branch"`
	GitCommit       string `json:"commit"`
	GitDirty        bool   `json:"dirty"`
	UserAgentString string `json:"user_agent"`
	Version         string `json:"version"`
}

// String implements Stringer
func (d *DetailStruct) String() string {
	if d == nil {
		return "n/a"
	}
	return fmt.Sprintf("%s %s", d.AppName, d.Version)
}

// ToUserAgentString formats a DetailStruct as a User-Agent string
func (s DetailStruct) ToUserAgentString() string {
	productName := s.AppName
	productVersion := s.Version

	productDetails := map[string]string{}

	user, err := user.Current()
	if err == nil {
		username := user.Username
		if username == "" {
			username = "unknown"
		}
	}

	detailParts := []string{}
	for k, v := range productDetails {
		detailParts = append(detailParts, fmt.Sprintf("%s: %s", k, v))
	}
	sort.Slice(detailParts, func(i, j int) bool {
		return detailParts[i] < detailParts[j]
	})
	productDetail := strings.Join(detailParts, ", ")

	return fmt.Sprintf("%s/%s (%s) %s (%s)", productName, productVersion, productDetail, runtime.GOOS, runtime.GOARCH)
}

func generateSemanticVersion(coreVersion string, branchName string, gitSHA string, dirty bool) string {
	v := coreVersion
	usedBranchName := false

	// append preReleaseIdentifier if needed
	if strings.EqualFold(branchName, "main") {
		usedBranchName = true
	} else {
		preReleaseIdentifier := "alpha"
		if strings.HasPrefix(branchName, "release-") {
			preReleaseIdentifier = branchNameToBuildMetadataSegment(branchName[len("release-"):])
			usedBranchName = true
		} else if strings.HasPrefix(branchName, "rc") {
			preReleaseIdentifier = branchName
			usedBranchName = true
		}
		v = v + "-" + preReleaseIdentifier
	}

	// append build metadata: SHA
	v += "+" + gitSHA

	// add branch name (unless used as a pre-release identifier)
	if !usedBranchName {
		v += "." + branchNameToBuildMetadataSegment(branchName)
	}

	// add dirty flag if needed
	if dirty {
		v += ".dirty"
	}

	return v
}

func branchNameToBuildMetadataSegment(name string) string {
	return strings.Replace(name, "_", "-", -1)
}
